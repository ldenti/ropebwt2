\documentclass{bioinfo}
\copyrightyear{2014}
\pubyear{2014}

\usepackage{amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{natbib}

\bibliographystyle{apalike}


\begin{document}
\firstpage{1}

\title[Constructing BWT]{Fast and lightweight construction of FM-index for large DNA sequence data sets}

\author[Li]{Heng Li}

\address{Broad Institute, 7 Cambridge Center, Cambridge, MA 02142, USA}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}
\editor{Associate Editor: XXXXXXX}
\maketitle

\begin{abstract}
\section{Summary:} We present a new algorithm to incrementally construct the
FM-index for a large genome or for billions of sequence reads. It is the first
algorithm that can build the index while implicitly sorting the sequences in
the reverse lexicographical order or the reverse-complement
lexicographical order without a separate sorting step. The
implementation is among the fastest CPU-based tools for indexing millions to
billions of short reads and scales better to longer sequence reads than other
existing algorithms.

\section{Availability and implementation:} https://github.com/lh3/ropebwt2

\section{Contact:} hengli@broadinstitute.org
\end{abstract}

\section{Introduction}

FM-index plays an important role in sequence alignment, {\it de novo}
assembly~\citep{Simpson:2012aa} and compression~\citep{Cox:2012ly}. Fast
and lightweight construction of FM-index for a large data set is the key to
these applications. In this context, a few algorithms have been developed for
DNA sequences that substaintially outperform earlier
algorithms~\citep{DBLP:journals/tcs/BauerCR13,DBLP:journals/corr/LiuLL14}.
However, they are only efficient for short reads and require special hardware,
a fast disk or high-end GPUs, for fast construction. A CPU-based all-purpose
algorithm without external storage is still lacking. This work aims to fill
this gap. In addition to fast construction, our algorithm is the first to
simultaneously sort input, which achieves better compression~\citep{Cox:2012ly}.

\section{Methods}
\begin{methods}
Let $\Sigma=\{{\tt A},{\tt C},{\tt G},{\tt T},{\tt N}\}$ be the \emph{alphabet}
of DNA with an arbitrary lexicographical order
${\tt A\char60C\char60G\char60T\char60N}$. Each elememnt in $\Sigma$ is
called a \emph{symbol} and a sequence of symbols called a \emph{string} over
$\Sigma$. Given a string $P$, $|P|$ is its length, $P[i]$ the symbol at
position $i$ and $P_i$ the suffix starting at $i$. A sentinel $\$$ is smaller
than all the other symbols. For simplicity, we let $P[-1]=\$$ for any string
$P$. We also introduce $\widetilde{P}$ for the reverse of $P$ and
$\overline{P}$ for the reverse complement of $P$.

Given a list of strings over $\Sigma$, $(P_i)_{0\le i<m}$, let
$T=P_0\$_0\ldots P_{m-1}\$_{m-1}$ with
${\tt\char36}_0{\tt\char60}\cdots{\char60\tt\char36}_{m-1}{\tt\char60A\char60C\char60G\char60T\char60N}$.
The \emph{suffix array} of $T$ is an integer array $S$ such that $S(i)$,
\mbox{$0\le i<|T|$}, is the position of the $i$-th smallest suffix in the
collection $T$.  The \emph{Burrows-Wheeler Transform}, or \emph{BWT}, of $T$
can be computed as \mbox{$B[i]=T[S(i)-1]$}. For the description of the
algorithm, we segment $B$ to \mbox{$B=B_{\tt\$}B_{\tt A}B_{\tt C}B_{\tt
G}B_{\tt T}B_{\tt N}$}, where \mbox{$B_a[i]=B[i+C(a)]$} and
\mbox{$C(a)=|\{j:T[j]<a\}|$} being the array of accumulative counts. By the
definition of suffix array and BWT, $B_a$ consists of all the symbols with
their next symbol in $T$ being $a$.

The above defines BWT for an order list of strings. We next seek to define BWT
for an unordered set of strings $\mathcal{C}$ by imposing an arbitrary sorting
order on $\mathcal{C}$.  We say list $(P_i)_i$ is in the \emph{reverse
lexicographical order} or \emph{RLO}, if $\widetilde{P}_i\le\widetilde{P}_j$
for any $i<j$; say it is in the \emph{reverse-complement lexicographical order}
or \emph{RCLO}, if $\overline{P}_i\le\overline{P}_j$ for any $i<j$.
The \emph{RLO-BWT} of $\mathcal{C}$, denoted by $B^{\rm RLO}(\mathcal{C})$,
is constructed by sorting strings in $\mathcal{C}$ in RLO and then applying
the procedure in the previous paragraph on the sorted list. \emph{RCLO-BWT}
$B^{\rm RCLO}(\mathcal{C})$ can be constructed in a similar way. In
$B^{\rm RCLO}(\{P_i\}_i\cup\{\overline{P}_j\}_j)$, the $k$-th smallest
sequence is the reverse complement of the $k$-th sequence in the FM-index. This
property removes the necessity of keep an extra array to link the rank and
the position of a sequence in the FM-index.

For the description of the algorithms, we define two string operations: ${\rm
rank}(c,k;B)$ and ${\rm insert}(c,k;B)$, where ${\rm
rank}(c,k;B)=|\{i<k:B[i]=c\}|$ gives the number of symbols $c$ before the
position $k$ in $B$, and ${\rm insert}(c,k;B)$ insert symbol $c$ after $k$
symbols in $B$ with all the symbols after position $k$ shifted to make room for
$c$. We implemented the two operations by representing the string with a
B+-tree, where a leaf keeps a run-length encoded string and an internal node
keeps the count of each symbol in the leaves descended from the node.

Algorithm 1 appends a string to an existing index by inserting each of its
symbol from the end of $P$. It was first described
by~\citet{DBLP:conf/cpm/ChanHL04}. Algorithm 2 constructs RLO-BWT or RCLO-BWT
in a similar manner to Algorithm 1. The difference is that it inserts $P[i]$ to
$[l,u)$, the suffix array interval of suffix $P_{i+1}$. This process is
analygous to a radix sort, sorting $P$ into the existing strings in the BWT.
Note that if we change line 1 to ``\mbox{$l\gets u\gets|\{i:B[i]=\$\}|$}'',
Algorithm 2 will be turned into Algorithm 1. Recall that the BCR
algorithm~\citep{DBLP:journals/tcs/BauerCR13} is in effect the multi-string
version of Algorithm 1. Following a similar reasoning, we can extend Algorithm
2 to insert multiple strings at the same time. This gives Algorithm 3, which is
reduced to Algorithm 1 or 2 if we insert one string at a time. We will see
later that for short strings, Algorithm 3 is substantially faster than
1 and 2, due to fewer cache misses and the possibility of partial parallelization.
The time complexity of all three algorithms is $O(n\log n)$, where
$n$ is the total number of symbols in the input.

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{A string $P$ and an existing BWT $B$ for $T$}
\KwOut{BWT for $TP\$$}
\BlankLine
\textbf{Function} {\sc InsertIO1}$(B,P)$
\Begin {
	$c\gets\$$; $k\gets|\{i:B[i]=\$\}|$\;
	\For{$i\gets|P|-1$ \KwTo $-1$} {
		${\rm insert}(P[i],k;B_c)$\;
		$k\gets {\rm rank}(P[i],k;B_c)+|\{a<c,j:B_a[j]=P[i]\}|$\;
		$c\gets P[i]$
	}
	{\bf return} $B$
}
\caption{Append one string}
\end{algorithm}

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{$B^{\rm RLO}(\mathcal{C})$ (or $B^{\rm RCLO}(\mathcal{C})$) and a string $P$}
\KwOut{$B^{\rm RLO}(\mathcal{C}\cup\{P\})$ (or $B^{\rm RCLO}(\mathcal{C}\cup\{P\})$)}
\BlankLine
\textbf{Function} {\sc InsertRLO1}$(B,P,{\it is\_comp})$
\Begin {
	$c\gets \$$\;
	\nl$[l,u)\gets \big[0,|\{i:B[i]=\$\}|\big)$\;
	\For{$i\gets|P|-1$ \KwTo $-1$} {
		$[l,u)\gets${\sc InsertAux}$(B,P[i],l,u,P[i+1],{\it is\_comp})$\;
	}
	{\bf return} $B$
}
\textbf{Function} {\sc InsertAux}$(B,c',l,u,c,{\it is\_comp})$
\Begin {
	$k\gets l$\;
	\If{is\_comp is {\bf true} {\bf and} $c'\not={\rm ``N"}$} {
		\For{$a=\$$ {\bf or} $c'<a<{\rm ``N"}$} {
			$k\gets k+\big[{\rm rank}(a,u;B_c)-{\rm rank}(a,l;B_c)\big]$\;
		}
	} \Else {
		\For{$\$\le a<c'$} {
			$k\gets k+\big[{\rm rank}(a,u;B_c)-{\rm rank}(a,l;B_c)\big]$\;
		}
	}
	${\rm insert}(c',k;B_c)$\;
	$m\gets|\{a<c,j:B_a[j]=c'\}|$\;
	{\bf return} $\big[{\rm rank}(c',l;B_c)+m,{\rm rank}(c',u;B_c)+m\big)$\;
}
\caption{Insert one string to RLO/RCLO-BWT}
\end{algorithm}

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{Existing BWT $B$ and a list of strings $\{P_j\}$}
\KwOut{Updated BWT $B$ with strings inserted in the specified order}
\BlankLine
\textbf{Function} {\sc InsertMulti}$(B,\{P_j\},{\it is\_sorted},{\it is\_comp})$
\Begin {
	\For{$0\le j<|\{P_j\}|$} {
		$A(j).c\gets \$$; $A(j).i\gets j$\;
		\If{is\_sorted is {\bf true}} {
			$[A(j).l,A(j).u)\gets [0,|\{i:B[i]=\$\}|)$\;
		} \Else {
			$A(j).l\gets A(j).u\gets|\{i:B[i]=\$\}|+j$\;
		}
	}
	$d\gets 0$\;
	\While{$|A|\not=0$} {
		\emph{Stable sort array $A$ by $A(\cdot).c$}\;
		\For{$0\le j<|A|$} {
			$c\gets A(j).c$\;
			$A(j).c\gets P_{A(j).i}[|P_{A(j).i}|-1-d]$\;
			$[A(j).l,A(j).u)$\;
			\hspace{0.1cm}$\gets${\sc InsertAux}$(B,c,A(j).l,A(j).u,A(j).c,{\it is\_comp})$\;
		}
		\emph{Remove $A(j)$ if $A(j).c=\$$}\;
		$d\gets d+1$\;
	}
}
\caption{Insert multiple strings}
\end{algorithm}
\end{methods}

\begin{table}[b]
\processtable{Performance of BWT construction}
{\footnotesize
\begin{tabular}{llcrrrl}
\toprule
Data$^1$& Algorithm&RCLO& Real  & CPU\% &RAM$^2$& Comments\\
\midrule
worm & nvbio       & -  & 316s  & 138\%&12.9G & See note$^3$\\
worm & ropebwt-bcr & -  & 480s  & 223\%&2.2G & -btORf\\
worm & Algorithm 3 & Yes& 506s  & 250\%&10.5G & -brRm10g \\
worm & Algorithm 3 & No & 647s  & 249\%&11.8G & -bRm10g \\
worm & beetl-bcr   & -  & 965s  & 259\%&1.8G & RAM disk$^4$\\
worm & beetl-bcr   & -  & 2092s & 122\%&1.8G & Network$^5$\\
worm & Algorithm 1 & -  & 5125s & 100\%&2.5G & -bR \\
worm & beetl-bcrext& -  & 5900s &  48\%&0.1G & Network$^5$\\
Venter&Algorithm 3 & Yes& 1.44h & 274\%&22.2G & -brRm10g \\
Venter&Algorithm 3 & No & 1.45h & 274\%&22.8G & -bRm10g \\
12878&nvbio        & -  &4.10h  & 471\%&63.8G & See note$^6$\\
12878&ropebwt-bcr  & - \\
12878&Algorithm 3  & Yes&4.96h  & 261\%&34.0G & -brRm10g \\
12878&Algorithm 3  & No &5.06h  & 248\%&60.9G & -bRm10g \\
12878&beetl-bcr    & - \\
\botrule
\end{tabular}}{$^1$Data sets -- {\it worm}: 66M$\times$100bp {\it C. eleganse} reads
from SRR065390; {\it Venter}: 32M$\times$875bp (in average) human reads
from~\citet{Levy:2007uq} with Sanger sequencing; {\it 12878}: 1206M$\times$101bp
human reads from~\citet{Depristo:2011vn}. $^2$Hardware -- CPU: 48 cores of
Xeon E5-2697v2 at 2.70GHz; GPU: one Nvidia Tesla K40; RAM: 128GB; Storage:
Isilon IQ 72000x and X400 over network. CPU time, wall-clock time and peak
memory are measured with GNU time. $^3$Run with option `-R -cpu-mem 4096 -gpu-mem
4096'. NVBio uses more CPU and GPU RAM than the specified. $^4$Results and
temporary files created on in-RAM virtual disk `/dev/shm'. $^5$Results and
temporary files created on Isilon's network file system. $^6$Run with
option `-R -cpu-mem 48000 -gpu-mem 4096'.}
\end{table}

\vspace*{-1em}
\section{Results and Discussion}
We implemented the algorithm in ropeBWT2 and evaluated its performance
together with BEETL (http://bit.ly/beetlGH), the original on-disk
implementation of BCR and BCRext, ropeBWT-BCR (https://github.com/lh3/ropebwt),
an in-memory reimplementation of BCR, and NVBio (http://bit.ly/NVBioGH), a
reimplementation of the CX1 GPU-based algorithm~\citep{DBLP:journals/corr/LiuLL14}.
Table~1 shows that for short reads, ropeBWT-BCR and NVBio are the fastest.
RopeBWT2 is close to them for short reads and the only one that scales well to
longer reads -- NVBio aborted on the Venter data set apparently due to
insufficient memory; BCR is not designed for this data as its time complexity
quadratic in the length of reads. On memory usage, BEETL is clearly the winner.
Other algorithms use similar RAM for the 12878 data set. NVBio and ropeBWT2
allow users to trade between speed and memory. The ropeBWT2 GitHub page shows
the results under other settings.  The relative performance is not changed
much.

RopeBWT2 has comparable performance to other algorithms and is more flexible
and richer in features. It will help to make FM-index based algorithms more
performant and more practical.
\vspace*{-1em}
\section*{Acknowledgement}
\paragraph{Funding\textcolon} NHGRI U54HG003037; NIH GM100233

\bibliography{ropebwt2}
\end{document}
