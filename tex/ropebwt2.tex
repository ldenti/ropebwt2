\documentclass[10pt]{article}
\usepackage{amsmath}

\usepackage[ruled,vlined]{algorithm2e}

\title{Constructing BWT for Sorted Strings}
\author{Heng Li}

\begin{document}
\maketitle

Let $\Sigma=\{\$,A,C,G,T,N\}$ be the alphabet for DNA with a predefined
lexicographical order $\$<A<C<G<T<N$, where $\$$ is the sentinel.  Each
elememnt in $\Sigma$ is called a \emph{symbol} and a sequence of symbol called
a \emph{string}. Let $|P|$ denote the length of $P$ and $P[i]$ the symbol at
position $i$. If $P[|P|-1]=\$$ and no other symbols in $P$ are sentinels, we
call $P$ as a \emph{text} or a \emph{document}. For simplicity, we also let
$P[-1]=\$$ for any string $P$.

Given a list of strings $P_i$, $0\le i<m$, their concatenation $T=P_0\ldots
P_{m-1}$ is called a \emph{collection}. Let $\$_i$ be the sentinel of $P_i$.
We futher introduce the lexicographical order between sentinels:
$\$_0<\cdots<\$_{m-1}<A<C<G<T<N$, such that when comparing suffixes, we do not
need to compare beyond sentinels.

The \emph{suffix array} of $T$ is an integer array $S$ such that $S(i)$, $0\le
i<|T|$, is the position of the $i$-th smallest suffix in the collection $T$.
The \emph{Burrows-Wheeler Transform}, or \emph{BWT}, of $T$ can be computed as
$B[i]=T[S(i)-1]$. For the description of the algorithm, we segment $B$ to
$B=B_{\$}B_AB_CB_GB_TB_N$, where $B_a[i]=B[i+C(a)]$ and $C(a)=|\{j:T[j]<a\}|$
being the array of accumulative counts. By the definition of suffix array and
BWT, $B_a$ consists of all the symbols with their next symbol in $T$ being
$a$.

Before we describe the algorithm for constructing BWT, we need two string
operations: ${\rm rank}(c,k;B)$ and ${\rm insert}(c,k;B)$, where ${\rm
rank}(c,k;B)=|\{i<k:B[i]=c\}|$ gives the number of symbols $c$ before the
position $k$ in $B$, and ${\rm insert}(c,k;B)$ insert symbol $c$ after $k$
symbols in $B$ with all the symbols after position $k$ shifted to
make room for $c$. These two operations can be implemented either by encoding
$B$ as a dynamic string with the rope data structure, which is essentially a
tree, or by recoding $B$ after each batch of insertions. RopeBWT2 takes the
former approach.

Algorithm 1 describes how to insert a string to an existing index in the input
order. It is essentially the same as the algorithm used by dynamic FM-index.
Algorithm 2 shows the method for inserting one string in the reverse
lexicographical order (RLO) or in the reverse-complement lexicographical order
(RCLO). Note that if we change line 1 to ``$u\gets|\{i:B[i]=\$\}|; l\gets u$'',
this algorithm will be turned into Algorithm 1. The first two algorithms insert
one string at a time. Algorithm 3 inserts multiple strings at the same time.
The function supports both the input order and RLO/RCLO. The input-order
version of this algorithm is essentially BCR. Inserting multiple strings helps
cache locality and opens the possibility to the parallelization of the loop at
line 1, both of which lead to a faster implementation for many short strings.

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{Existing BWT $B$ for text $T$ and a string $P$}
\KwOut{BWT $B$ for text $T\circ P$}
\BlankLine
\textbf{Function} {\sc InsertIO1}$(B,P)$
\Begin {
	$k\gets|\{i:B[i]=\$\}|$\;
	$c\gets\$$\;
	\For{$i\gets|P|-1$ \KwTo $-1$} {
		${\rm insert}(P[i],k;B_c)$\;
		$k\gets {\rm rank}(P[i],k;B_c)+|\{a<c,j:B_a[j]=P[i]\}|$\;
		$c\gets P[i]$
	}
	{\bf return} $B$
}
\caption{Insert one string in the input order}
\end{algorithm}

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{Existing BWT $B$ in RLO/RCLO and a string $P$}
\KwOut{BWT $B$ with $P$ inserted in RLO/RCLO}
\BlankLine
\textbf{Function} {\sc InsertRLO1}$(B,P,{\it is\_RCLO})$
\Begin {
	\nl$[l,u)\gets \big[0,|\{i:B[i]=\$\}|\big)$\;
	$c\gets \$$\;
	\For{$i\gets|P|-1$ \KwTo $-1$} {
		$[l,u)\gets${\sc InsertAux}$(B,l,u,c,P[i],{\it is\_RCLO})$\;
		$c\gets P[i]$\;
	}
	{\bf return} $B$
}
\textbf{Function} {\sc InsertAux}$(B,l,u,c,c',{\it is\_RCLO})$
\Begin {
	$k\gets l$\;
	\If{is\_RCLO is {\bf true} {\bf and} $c\not={\rm ``N"}$} {
		\For{$a=\$$ {\bf or} $c'<a<{\rm ``N"}$} {
			$k\gets k+\big[{\rm rank}(a,u;B_c)-{\rm rank}(a,l;B_c)\big]$\;
		}
	} \Else {
		\For{$\$\le a<c'$} {
			$k\gets k+\big[{\rm rank}(a,u;B_c)-{\rm rank}(a,l;B_c)\big]$\;
		}
	}
	${\rm insert}(c',k;B_c)$\;
	$m\gets|\{a<c,j:B_a[j]=c'\}|$\;
	{\bf return} $\big[{\rm rank}(c',l;B_c)+m,{\rm rank}(c',u;B_c)+m\big)$\;
}
\caption{Insert one string in RLO/RCLO}
\end{algorithm}

\begin{algorithm}[ht]
\DontPrintSemicolon
\footnotesize
\KwIn{Existing BWT $B$ for text $T$ and a set of strings $\{P_j\}$}
\KwOut{Updated BWT $B$ with strings inserted in the specified order}
\BlankLine
\textbf{Function} {\sc InsertMultiRLO}$(B,\{P_j\},{\it is\_sorted},{\it is\_RCLO})$
\Begin {
	\For{$0\le j<|\{P_j\}|$} {
		$A(j).i\gets j$\;
		$A(j).c\gets \$$\;
		$[A(j).l,A(j).u)\gets [0,|\{i:B[i]=\$\}|)$\;
		\If{is\_sorted is {\bf false}} {
			$A(j).l\gets A(j).u$
		}
	}
	$d\gets 0$\;
	\While{$|A|\not=0$} {
		\emph{Stable sort array $A$ by $A(\cdot).c$}\;
		\nl\For{$0\le j<|A|$} {
			$c\gets A(j).c$\;
			$A(j).c\gets P_{A(j).i}[|P_{A(j).i}|-1-d]$\;
			$[A(j).l,A(j).u)\gets${\sc InsertAux}$(B,A(j).l,A(j).u,c,A(j).c,{\it is\_RCLO})$\;
		}
		\emph{Remove $A(j)$ if $A(j).c=\$$}\;
		$d\gets d+1$\;
	}
}
\caption{Insert multiple strings}
\end{algorithm}

\end{document}
